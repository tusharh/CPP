1) Swapping values 
x = x ^ y;
y = x ^ y;
x = x ^ y;

if x =  5 & y = 2,
ouput would be 
x = 2 & y = 5 after above operation.


2) To get hardware information in windows use wmic
{
    char buffer[128];
    std::string result = "";
    std::shared_ptr<FILE> pipe(popen("wmic logicaldisk C: get VolumeSerialNumber", "r"), pclose);
    if (!pipe) throw std::runtime_error("popen() failed!");

    while (!feof(pipe.get()))
    {
        if (fgets(buffer, 128, pipe.get()) != NULL)
            result += buffer;
    }
    
}

3) Get common location to store data

QString CommonDataLocation = "";

#ifdef Q_OS_WIN
    QSettings currVersionKey("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",QSettings::NativeFormat);
    QString OSType(currVersionKey.value("InstallationType").toString());

    if("Server" == OSType)
    {
        QSettings CommonDataKey("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",QSettings::NativeFormat);
        CommonDataLocation = CommonDataKey.value("Common AppData").toString() + "\\MangoAppsUploader\\";
        CommonDataLocation = QDir::fromNativeSeparators(CommonDataLocation);
    }
#endif


4) Moving files to recycle bin
{
    int success = -1;
    QString strNativeFilePath = QDir::toNativeSeparators(strFilePath);
    qDebug()<<"Native style path = "<<strNativeFilePath;

#ifdef Q_OS_WIN

    if(strNativeFilePath.length() > 255)
    {
        QString file = FileSystem::longWinPath(strNativeFilePath);

        wchar_t* input = new wchar_t[file.size()+1];
        file.toWCharArray(input);
        input[file.size()]= L'\0';

        long length = GetShortPathName(input, NULL, 0);
        wchar_t* output = new wchar_t[length];
        GetShortPathNameW(input,output,length);

        strNativeFilePath = QString::fromWCharArray(output,length-1);

        strNativeFilePath = strNativeFilePath.replace("\\\\?\\","");

        delete [] input;
        delete [] output;
    }

    std::wstring wstrFilePath = strNativeFilePath.toStdWString();
    int len = _tcslen(wstrFilePath.c_str());
    TCHAR *pszFrom = new TCHAR[len + 2];
    _tcscpy(pszFrom, wstrFilePath.c_str());
    pszFrom[len] = 0;
    pszFrom[len + 1] = 0;

    SHFILEOPSTRUCT fileop;
    fileop.hwnd = NULL;    // no status display
    fileop.wFunc = FO_DELETE;  // delete operation
    fileop.pFrom = pszFrom;  // source file name as double null terminated string
    fileop.pTo = NULL;    // no destination needed
    fileop.fFlags = FOF_NOCONFIRMATION | FOF_SILENT | FOF_ALLOWUNDO;  // do not prompt the user
    fileop.fAnyOperationsAborted = FALSE;
    fileop.lpszProgressTitle = NULL;
    fileop.hNameMappings = NULL;

    success = SHFileOperation(&fileop);
    delete[] pszFrom;

  if(0 == success)
      success = 1;
  else
  {
      qDebug()<<"File remove Error code - "<< success;
      success = 0;
  }
#endif

#ifdef Q_OS_MAC


    std::string stdPath = strNativeFilePath.toStdString();
    UInt8* strUInt8Path = new UInt8[stdPath.length() + 1];
    memcpy (strUInt8Path, stdPath.c_str(), stdPath.length() + 1);

    FSRef fsRef;
    OSStatus status = -1;

    status = FSPathMakeRefWithOptions(strUInt8Path,
                                                 kFSPathMakeRefDoNotFollowLeafSymlink,
                                                 &fsRef,
                                                 NULL);

    status = FSMoveObjectToTrashSync(&fsRef, NULL, kFSFileOperationDefaultOptions);

    if(0 == status)
        success = 1;
    else
    {
        qDebug()<<"File remove Error code - "<< success;
        success = 0;
    }
#endif
  qDebug()<<"File or Directory delete SUCCESS = "<<success;
  return success;
}

